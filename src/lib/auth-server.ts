/**
 * Server-Side Authentication - taxbook-pro
 * Generated: 2026-01-19
 *
 * Server-only Supabase authentication utilities.
 * Use this in Server Components, Route Handlers, and Server Actions.
 *
 * For client components, use '@/lib/auth' instead.
 */

import 'server-only';

import { createServerClient as createSupabaseServerClient, type CookieOptions } from '@supabase/ssr';
import { cookies } from 'next/headers';
import type { Result } from '@/types/errors';
import type { AuthUser, AuthError } from './auth';
import { mapAuthError } from './auth';

// ============================================================
// SERVER CLIENT
// ============================================================

/**
 * Create Supabase client for server components/actions.
 * Use this in Server Components, Route Handlers, Server Actions.
 *
 * @example
 * // In a Server Component
 * const supabase = await createServerClient();
 * const { data } = await supabase.from('posts').select();
 *
 * @example
 * // In a Route Handler
 * export async function GET() {
 *   const supabase = await createServerClient();
 *   const { data: { user } } = await supabase.auth.getUser();
 * }
 */
export async function createServerClient() {
  const cookieStore = await cookies();

  return createSupabaseServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet: { name: string; value: string; options: CookieOptions }[]) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            );
          } catch {
            // Called from Server Component - cookies are read-only
          }
        },
      },
    }
  );
}

// ============================================================
// GET USER (SERVER)
// ============================================================

/**
 * Get the currently authenticated user (server-side).
 * Returns Result with user or error.
 *
 * @example
 * // In a Server Component
 * const result = await getUser();
 * if (!result.ok) {
 *   redirect('/login');
 * }
 * const user = result.value;
 */
export async function getUser(): Promise<Result<AuthUser, AuthError>> {
  try {
    const supabase = await createServerClient();
    const { data: { user }, error } = await supabase.auth.getUser();

    if (error) {
      return {
        ok: false,
        error: mapAuthError(error),
      };
    }

    if (!user) {
      return {
        ok: false,
        error: { code: 'user_not_found', message: 'No authenticated user' },
      };
    }

    return {
      ok: true,
      value: {
        id: user.id,
        email: user.email!,
        emailConfirmed: !!user.email_confirmed_at,
        createdAt: new Date(user.created_at),
      },
    };
  } catch {
    return {
      ok: false,
      error: { code: 'network_error', message: 'Failed to check authentication' },
    };
  }
}

/**
 * Require authentication in a Server Component or Route Handler.
 * Throws redirect to login page if not authenticated.
 *
 * @example
 * // In a Server Component
 * const user = await requireAuth();
 * // user is guaranteed to be authenticated
 */
export async function requireAuth(): Promise<AuthUser> {
  const result = await getUser();

  if (!result.ok) {
    // Dynamic import to avoid importing redirect at module level
    const { redirect } = await import('next/navigation');
    redirect('/login');
    // TypeScript doesn't know redirect throws, so we need unreachable code
    throw new Error('Unreachable');
  }

  return result.value;
}

// ============================================================
// GENERATED BY MENTAL MODELS SDLC
// ============================================================
